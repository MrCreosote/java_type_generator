package us.kbase.rpc;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.node.ArrayNode;
import org.codehaus.jackson.node.ObjectNode;
import org.codehaus.jackson.type.TypeReference;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.servlet.ServletHolder;

public class JsonServerServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private ObjectMapper mapper;
	private Map<String, Method> rpcCache;
	
	public void startupServer(int port) throws Exception {
		Server server = new Server(port);
		ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
        context.setContextPath("/");
        server.setHandler(context);
        context.addServlet(new ServletHolder(this),"/*");
        server.start();
        server.join();
	}
	
	public JsonServerServlet() {
		this.mapper = new ObjectMapper().withModule(new JacksonTupleModule());
		this.rpcCache = new HashMap<String, Method>();
		for (Method m : getClass().getMethods()) {
			if (m.isAnnotationPresent(JsonServerMethod.class)) {
				JsonServerMethod ann = m.getAnnotation(JsonServerMethod.class);
				rpcCache.put(ann.rpc(), m);
			}
		}		
	}
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		InputStream input = request.getInputStream();
		JsonNode node = mapper.readTree(new UnclosableInputStream(input));
		JsonNode methodNode = node.get("method");
		ArrayNode paramsNode = (ArrayNode)node.get("params");
		String rpcName	= (methodNode!=null && !methodNode.isNull()) ? methodNode.asText() : null;
		Method rpcMethod = rpcCache.get(rpcName);
		if (rpcMethod == null)
			throw new IllegalStateException("Can not find rpc [" + rpcName + "] in server class: " + getClass().getName());
		boolean isTuple = rpcMethod.getAnnotation(JsonServerMethod.class).tuple();
		if (paramsNode.size() != rpcMethod.getGenericParameterTypes().length)
			throw new IllegalStateException("Wrong parameter count for rpc: " + rpcName);
		Object[] methodValues = new Object[paramsNode.size()];
		for (int typePos = 0; typePos < paramsNode.size(); typePos++) {
			JsonNode jsonData = paramsNode.get(typePos);
			Type paramType = rpcMethod.getGenericParameterTypes()[typePos];
			PlainTypeRef paramJavaType = new PlainTypeRef(paramType);
			methodValues[typePos] = mapper.readValue(jsonData, paramJavaType);
		}
		try {
			Object result = rpcMethod.invoke(this, methodValues);
			if (!isTuple) {
				result = Arrays.asList(result);
			}
			ObjectNode ret = mapper.createObjectNode();
			ret.put("version", "1.1");
			ret.put("result", mapper.valueToTree(result));
			response.setContentType("application/json-rpc");
			OutputStream output	= response.getOutputStream();
			mapper.writeValue(new UnclosableOutputStream(output), ret);
			output.flush();
		} catch (Exception e) {
			throw new IllegalStateException(e);
		}
	}

	private static class PlainTypeRef extends TypeReference<Object> {
		Type type;
		PlainTypeRef(Type type) {
			this.type = type;
		}
		
		@Override
		public Type getType() {
			return type;
		}
	}
	
	private static class UnclosableInputStream extends InputStream {
		private InputStream inner;
		private boolean isClosed = false;
		
		public UnclosableInputStream(InputStream inner) {
			this.inner = inner;
		}
		
		@Override
		public int read() throws IOException {
			if (isClosed)
				return -1;
			return inner.read();
		}
		
		@Override
		public int available() throws IOException {
			if (isClosed)
				return 0;
			return inner.available();
		}
		
		@Override
		public void close() throws IOException {
			isClosed = true;
		}
		
		@Override
		public synchronized void mark(int readlimit) {
			inner.mark(readlimit);
		}
		
		@Override
		public boolean markSupported() {
			return inner.markSupported();
		}
		
		@Override
		public int read(byte[] b) throws IOException {
			if (isClosed)
				return 0;
			return inner.read(b);
		}
		
		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			if (isClosed)
				return 0;
			return inner.read(b, off, len);
		}
		
		@Override
		public synchronized void reset() throws IOException {
			if (isClosed)
				return;
			inner.reset();
		}
		
		@Override
		public long skip(long n) throws IOException {
			if (isClosed)
				return 0;
			return inner.skip(n);
		}
	}
	
	private static class UnclosableOutputStream extends OutputStream {
		OutputStream inner;
		boolean isClosed = false;
		
		public UnclosableOutputStream(OutputStream inner) {
			this.inner = inner;
		}
		
		@Override
		public void write(int b) throws IOException {
			if (isClosed)
				return;
			inner.write(b);
		}
		
		@Override
		public void close() throws IOException {
			isClosed = true;
		}
		
		@Override
		public void flush() throws IOException {
			inner.flush();
		}
		
		@Override
		public void write(byte[] b) throws IOException {
			if (isClosed)
				return;
			inner.write(b);
		}
		
		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			if (isClosed)
				return;
			inner.write(b, off, len);
		}
	}
}
