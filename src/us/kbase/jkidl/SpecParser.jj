options{
    IGNORE_CASE = false;
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(SpecParser)

package us.kbase.jkidl;

import java.io.*;

@SuppressWarnings({"unused", "serial"})
public class SpecParser {
	static String lastComment;
  
    public static void main(String args[]) throws Exception {
        String fileName = null;
        if (args.length < 1) {
            System.out.println("Usage: <program> <spec-file>");
        	return;
        }
        fileName = args[0];
        SpecParser p = null;
        try {
            p = new SpecParser(new DataInputStream(new FileInputStream(fileName)));
        } catch (FileNotFoundException e) {
            System.out.println("File " + fileName + " not found.");
            return;
        }
        ParseNode root = p.SpecStatement();
        root.printTreeInfo();
  	}

  	public ParseNode getBeginPlaceNode(Token t) {
    	ParseNode node = new ParseNode("BEG_PLACE");
   	 	node.setProperty("LINE",""+t.beginLine);
    	node.setProperty("COLUMN",""+t.beginColumn);
    	return node;
  	}
  	
  	public ParseNode getEndPlaceNode(Token t) {
    	ParseNode node = new ParseNode("END_PLACE");
    	node.setProperty("LINE",""+t.endLine);
    	node.setProperty("COLUMN",""+t.endColumn);
    	return node;
  	}
}

PARSER_END(SpecParser)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
|   "/*" : WithinComment
}

<WithinComment> SKIP :
{
  "*/"
  {
    SpecParser.lastComment = "/*" + image;
  }
  : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}


TOKEN: 
{
    <T_include:"#include">
|   <T_module:"module">
|   <T_auth:"authentication">
|   <T_required:"required">
|   <T_optional:"optional">
|   <T_none:"none">
|   <T_typedef:"typedef">
|   <T_funcdef:"funcdef">
|   <T_string:"string">
|   <T_int:"int">
|   <T_float:"float">
|   <T_unobj:"UnspecifiedObject">
|   <T_list:"list">
|   <T_mapping:"mapping">
|   <T_structure:"structure">
|   <T_tuple:"tuple">
|   <T_returns:"returns">
|   <T_round_open_bracket:"(">
|   <T_round_close_bracket:")">
|   <T_comma:",">
|   <T_dot:".">
|   <T_semicolon:";">
|   <T_colon:":">
|   <T_figure_open_bracket:"{">
|   <T_figure_close_bracket:"}">
}


TOKEN:
{
    < S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
|   < #LETTER: ["a"-"z", "A"-"Z"] >
|   < #DIGIT: ["0" - "9"] >
|   < #SPECIAL_CHARS: "$" | "_" | "-">
|   < INCLUDE_LITERAL: "#include" ([" ", "\t"])* "<" (~[">"])* ">">
}


ParseNode SpecStatement():
{
  ParseNode specNode = new ParseNode("SPEC");
  ParseNode includeListNode;
  ParseNode moduleListNode;
}
{
  includeListNode = IncludeList()
  moduleListNode = ModuleList()
  <EOF>
  {
    specNode.addChild(includeListNode);
    specNode.addChild(moduleListNode);
    return specNode;
  }
}

ParseNode IncludeList():
{
  ParseNode retNode = new ParseNode("INCLUDES");
  ParseNode includeNode;
}
{
  (
    includeNode = Include()
    {
      retNode.addChild(includeNode);
    }
  )*
  { return retNode; }
}

ParseNode Include():
{
  Token begToken;
  Token pathToken;
  ParseNode retNode = new ParseNode("INCLUDE");
}
{
  //begToken = "#include"
  pathToken = <INCLUDE_LITERAL>
  {
    retNode.setProperty("PATH", pathToken.toString());
    return retNode;
  }
}

ParseNode ModuleList():
{
  ParseNode retNode = new ParseNode("MODULES");
  ParseNode moduleNode;
}
{
  (
    moduleNode = Module()
    {
      retNode.addChild(moduleNode);
    }
  )*
  { return retNode; }
}

ParseNode Module():
{
  ParseNode retNode = new ParseNode("MODULE");
  ParseNode elementNode;
  Token srvToken;
  Token nameToken;
  Token t;
}
{
  { srvToken = null; }
  "module"
  {
    if (lastComment != null)
	    retNode.setProperty("comment", lastComment);
    lastComment = null;
  }
  [
    LOOKAHEAD (<S_IDENTIFIER> ":")
    srvToken = <S_IDENTIFIER>
    ":"
  ]
  nameToken = <S_IDENTIFIER>
  "{"
  (
    (      (
        elementNode = Typedef()
      )
      |
      (
        elementNode = Funcdef()
      )
	  |
	  (		elementNode = Auth()
	  )
	)
	t = ";"
    {
      lastComment = null;
      //elementNode.addChild(getEndPlaceNode(t));
      retNode.addChild(elementNode);
    }  )*
  "}"
  ";"  {
    if (srvToken != null)
	    retNode.setProperty("service", srvToken.toString()); 
    retNode.setProperty("name", nameToken.toString()); 
    return retNode;
  }
}

ParseNode Typedef():
{
  ParseNode node = new ParseNode("TYPEDEF");
  ParseNode typeNode;
  Token t;
}
{
  "typedef"
  {
    if (lastComment != null)
	    node.setProperty("comment", lastComment);
    lastComment = null;
  }
  typeNode = Type()
  t = <S_IDENTIFIER>
  {
    node.addChild(typeNode);
    node.setProperty("name", t.toString());
    //node.addChild(getEndPlaceNode(t));
    return node;
  }
}

ParseNode Type():
{  ParseNode node = new ParseNode("TYPE");
  ParseNode subNode;
  Token t;
  Token moduleToken;
  Token varToken;
}
{
  {
    t = null;    moduleToken = null;
    varToken = null;
  }
  (
  	(
  	  t = "string"  	)
	|   	(
  	  t = "int"
  	)
	| 
  	(
  	  t = "float"
  	)
	| 
  	(
  	  t = "UnspecifiedObject"
  	)
	| 
    (
      t = "list"
      "<" subNode = Type()
      { node.addChild(subNode); }
      ">"
    )
  	|
  	(  	  t = "mapping"
  	  "<" subNode = Type()
      { node.addChild(subNode); }
  	  "," Type()
      { node.addChild(subNode); }
  	  ">"
  	)
  	|
  	(
  	  t = "tuple"
  	  "<" subNode = Param()
      { node.addChild(subNode); }
  	  ("," subNode = Param()
      { node.addChild(subNode); }
  	  )* ">"
  	)
	|
	(	  t = "structure"
	  "{"
	  (		  subNode = StructItem() ";"
          { node.addChild(subNode); }
	  )*
	  "}"	)
	|
	(
	  [
    	LOOKAHEAD (<S_IDENTIFIER> ".")
    	moduleToken = <S_IDENTIFIER>
    	"."
  	  ]
	  varToken = <S_IDENTIFIER>
	)
  )  {
    node.setProperty("kind", t == null ? "ref" : t.toString());
    if (t == null) {		if (moduleToken != null)
			node.setProperty("module", moduleToken.toString());
		node.setProperty("ref", varToken.toString());
    }    return node;
  }
}

ParseNode StructItem():
{  ParseNode node = new ParseNode("STRUCT_ITEM");
  ParseNode typeNode;
  Token t;
}
{	typeNode = Type()
	t = <S_IDENTIFIER>
  { node.addChild(typeNode); }
  { node.setProperty("name", t.toString()); }
  { return node; }
}

ParseNode Auth():
{
  ParseNode node = new ParseNode("AUTH");
  Token t;
}
{
  "authentication"
  (
 	(		t = "required"
  	)
    |
    (
	  t = "optional"
    )
    |
    (
	  t = "none"
    )
  )
  { node.setProperty("kind", t.toString()); }
  { return node; }
}

ParseNode Funcdef():
{
  ParseNode node = new ParseNode("FUNCDEF");
  ParseNode args;
  ParseNode ret;
  ParseNode auth;
  Token t;
}
{
  "funcdef"
  {
    if (lastComment != null)
	    node.setProperty("comment", lastComment);
    lastComment = null;
  }
  t = <S_IDENTIFIER>
  "("
  args = Params()
  { node.addChild(args); }
  ")"
  "returns"
  "("
  ret = Params()
  { node.addChild(ret); }
  ")"
  [ auth = Auth()
  { node.addChild(auth); }
  ]
  { node.setProperty("name", t.toString());
    return node;
  }
}

ParseNode Params():
{
  ParseNode node = new ParseNode("PARAMS");
  ParseNode paramNode;
}
{
  [
  	paramNode = Param()
  	{ node.addChild(paramNode); }
    (
      ","
  	  paramNode = Param()
	  { node.addChild(paramNode); }
    )*
  ]
  { return node; }
}

ParseNode Param():
{
  ParseNode node = new ParseNode("PARAM");
  ParseNode type;
  Token name = null;
}
{
  type = Type()
  { node.addChild(type); }
  [ name = <S_IDENTIFIER>
    { node.setProperty("name", name.toString()); }
  ]
  { return node; }
}
